# Catalogue

## 1 Two Sum

### Description
Given an array of integers, return **indices** of the two numbers such that they add up to a specific target.
You may assume that each input would have **exactly** one solution, and you may not use the same element twice.

**Example**


>Given nums = [2, 7, 11, 15], target = 9,
>
>Because nums[0] + nums[1] = 2 + 7 = 9,
>return [0, 1].


Result:[Two Sum](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/twoSum.py)

## 2 Add Two Numbers

### Description
You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
**Input**: (2 -> 4 -> 3) + (5 -> 6 -> 4)
**Output**: 7 -> 0 -> 8

**é¢˜ç›®ç†è§£**ï¼šç´¯åŠ çš„å‡½æ•°ï¼Œé“¾è¡¨çš„å¤´æ˜¯ä¸ªä½ï¼Œä»¥æ­¤ç±»æ¨ã€‚ä¾‹å­æŒ‰ç…§åè¿›åˆ¶åŠ å‡å°±æ˜¯ï¼š342 + 465 =807ã€‚åœ¨å®ç°è¿‡ç¨‹ä¸­ï¼Œæ³¨æ„è¿›ä½ã€‚
Result:[Add Two Numbers](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/2_addTwoNumbers.py)

## 7 Reverse Integer

### Description
Reverse digits of an integer.
**Example1**: x = 123, return 321
**Example2**: x = -123, return -321

**Note**:
The input is assumed to be a 32-bit signed integer. Your function should **return 0 when the reversed integer overflows**.

**é¢˜ç›®ç†è§£**ï¼šè¿™é‡Œè¦æ³¨æ„æœ‰ä¸ª integer overflowsã€‚

Result:[Reverse Integer](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/7_reverse_integer.py)

## 9 Palindrome Number

### Description
Determine whether an integer is a palindrome. Do this without extra space.

**ç†è§£é¢˜ç›®**ï¼šåˆ¤æ–­ä¸€ä¸ªæ•´å½¢æ•°å­—æ˜¯å¦æ˜¯å›æ–‡ã€‚

[click to show spoilers.](https://leetcode.com/problems/palindrome-number/#/description)

Result:[Palindrome Number](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/9_palindromeNumber.py)

## 13 Roman to Integer

### Description
Given a roman numeral, convert it to an integer.
Input is guaranteed to be within the range from 1 to 3999.

**é¢˜ç›®ç†è§£**: å°†ç½—é©¬æ•°å­—è½¬æ¢æˆæ•´å‹æ•°å­—ã€‚é¦–å…ˆè¦ç†è§£ç½—é©¬æ•°å­—çš„è®¡ç®—æ–¹å¼ã€‚å¤§æ•°å·¦è¾¹çš„ä¸ºå‡å³è¾¹æ˜¯åŠ ã€‚

Result:[Roman to Integer](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/13_romanToint.py)

## 14 Longest Common Prefix

### Description
Write a function to find the longest common prefix string amongst an array of strings.

Result:[Longest Common Prefix](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/14_LongestCommonPrefix.py)

## 20 Valid Parentheses

### Description
Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.

**é¢˜ç›®ç†è§£**ï¼šè¿™é“é¢˜ç”¨æ ˆçš„æ–¹å¼å®ç°ï¼Œéå†å­—ç¬¦ä¸²ï¼Œæ£€éªŒåˆ°å·¦æ‹¬å·å…¥æ ˆï¼Œæ£€éªŒåˆ°å³æ‹¬å·æ—¶ï¼Œå‡ºæ ˆæ£€éªŒæ˜¯å¦åŒ¹é…ï¼Œæœ€åæ£€éªŒæ ˆæ˜¯å¦ä¸ºç©ºï¼Œæ’é™¤å³æ‹¬å·ç¼ºå¤±çš„æƒ…å†µã€‚

Result:[Valid Parentheses](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/20_ValidParentheses.py)

## 21 Merge Two Sorted Lists

### Description
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

**é¢˜ç›®ç†è§£** åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ï¼Œåˆæˆçš„åˆ—è¡¨ä¹Ÿæ˜¯æœ‰åºçš„ã€‚æ–¹æ³•æ˜¯ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹ï¼Œç©¿æ’è¿æ¥ä¸¤ä¸ªè¾“å…¥é“¾è¡¨ã€‚

Resultï¼š[Merge Two Sorted Lists](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/21_MergeTwoSortedLists.py)

## 26 Remove Duplicates from Sorted Array

### Description
Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.
**Do not allocate extra space for another array, you must do this in place with constant memory.**

For example,
Given input array *nums = [1,1,2]*,

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length.

Result:[Remove Duplicates from Sorted Array](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/26_RmDuplicatesFSortedArray.py)

## 27 Remove Element

### Description
Given an array and a value, remove all instances of that value in place and return the new length.

Do not allocate extra space for another array, you must do this in place with constant memory.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.

**Example:**
Given input array nums = [3,2,2,3], val = 3

Your function should return length = 2, with the first two elements of nums being 2.

**é¢˜ç›®ç†è§£**ï¼šå’Œ[26 Remove Duplicates from Sorted Array](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/Catalogue.mdown#26-remove-duplicates-from-sorted-array) ç±»ä¼¼ï¼Œåœ¨åŸåˆ—è¡¨ä¸­è®¾ç½®ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªè¿›è¡Œéå†ï¼Œå¦ä¸€ä¸ªè¿›è¡Œèµ‹å€¼å¹¶è®¡ç®—æ–°çš„length

Result:[Remove Element](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/27_RemoveElement.py)

## 28 Implement strStr()

### Description
Implement strStr().

Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

**é¢˜ç›®ç†è§£**: ç®€å•çš„ç®—æ³•ï¼Œå¤æ‚åº¦O(n^2),å¯ä»¥ä½¿ç”¨kmpç®—æ³•å°†å¤æ‚åº¦é™è‡³O(n)

Result:[Implement strStr()](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/28_strStr.py)

## 35 Search Insert Position

### Description
Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

Here are few examples.
>[1,3,5,6], 5 â†’ 2

>[1,3,5,6], 2 â†’ 1

>[1,3,5,6], 7 â†’ 4

>[1,3,5,6], 0 â†’ 0

[View in Leetcode](https://leetcode.com/problems/search-insert-position/#/description)

Result: [Search Insert Position](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/35_SearchInsert.py)

## 38 Count and Say

### Description
The count-and-say sequence is the sequence of integers beginning as follows:
1, 11, 21, 1211, 111221, ...

>1 is read off as "one 1" or 11.

>11 is read off as "two 1s" or 21.

>21 is read off as "one 2, then one 1" or 1211.

Given an integer n, generate the nth sequence.

Note: The sequence of integers will be represented as a string.

**é¢˜ç›®ç†è§£**: éœ€è¦ç”¨åˆ°è¿­ä»£ã€‚

[View in Leetcode](https://leetcode.com/problems/count-and-say/#/description)

Result: [Count and Say](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/38_CountAndSay.py)

## 53 Maximum Subarray

### Description
Find the contiguous subarray within an array (containing at least one number) which has the largest sum.

For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.

[Maximum Subarray](https://github.com/NaughtyFlame/LeetCode/tree/master/Algorithms/0-99/53_maxSubArray.py)

## 58 Length of Last Word

### Description
Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.

If the last word does not exist, return 0.

**Note:** A word is defined as a character sequence consists of non-space characters only.

For example,
Given s = **"Hello World"**,
return **5**.

Result: [Length of Last Word](https://github.com/NaughtyFlame/LeetCode/tree/master/Algorithms/0-99/58_LenLastWord.py)

## 66 Plus One

### Description
Given a non-negative integer represented as a **non-empty** array of digits, plus one to the integer.

You may assume the integer do not contain any leading zero, except the number 0 itself.

The digits are stored such that the most significant digit is at the head of the list.

Result: [Plus One](https://github.com/NaughtyFlame/LeetCode/tree/master/Algorithms/0-99/66_PlusOne.py)

## 67 Add Binary

### Description
Given two binary strings, return their sum (also a binary string).

For example,
a = "11"
b = "1"
Return "100".

[view in Leetcode](https://leetcode.com/problems/add-binary/#/description)

Result: [Add Binary](https://github.com/NaughtyFlame/LeetCode/tree/master/Algorithms/0-99/67_addBinary.py)

## 69 Sqrt(x)

### Description
Implement int sqrt(int x).
Compute and return the square root of x.

[view in Leetcode](https://leetcode.com/problems/sqrtx/#/description)

åˆ†æï¼šæ­¤é¢˜éœ€è¦è¿”å›çš„å€¼æ˜¯intå½¢å¼çš„ï¼Œæ‰€ä»¥ç”¨äºŒåˆ†æ³•æœ€ä¸ºåˆé€‚ï¼Œå¦‚æœè®¡ç®—floatæ ¼å¼å¹³æ–¹æ ¹ï¼Œå¯ä»¥ä½¿ç”¨ç‰›é¡¿è¿­ä»£æ³•ã€‚

Result: [Sqrt(x)](https://github.com/NaughtyFlame/LeetCode/tree/master/Algorithms/0-99/69_mysqrt_1.py)

## 70 Climbing Stairs

### Description
You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

**Note** : Given n will be a positive integer.

[view in Leetcode](https://leetcode.com/problems/climbing-stairs/#/description)

Result: [Climbing Stairs](https://github.com/NaughtyFlame/LeetCode/tree/master/Algorithms/0-99/70_climbStairs.py)

## 83 Remove Duplicates from Sorted List

### Description
Given a sorted linked list, delete all duplicates such that each element appear only once.

For example,

Given **1->1->2**, return **1->2**.

Given **1->1->2->3->**3, return **1->2->3**.

[view in leetcode](https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/)

[Solution](https://github.com/NaughtyFlame/LeetCode/tree/master/Algorithms/0-99/083_Remove_Duplicates_1.py)

## 88 Merge Sorted Array
Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

**Note**:

You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.

[view in leetcode](https://leetcode.com/problems/merge-sorted-array/description/)

[Solution](https://github.com/NaughtyFlame/LeetCode/tree/master/Algorithms/0-99/088_Merge_Sorted_Array.py)

## 94 Binary Tree Inorder Traversal

### Description
Given a binary tree, return the inorder traversal of its nodes' values.

For example:
Given binary tree **[1,null,2,3]**,
```
   1
    \
     2
    /
   3
```
return **[1,3,2]**.

ä¸­åºéé€’å½’éå†ã€‚

[Solution](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/94_Binary_Tree_Inorder_Traversal.py)

## 121 Best Time to Buy and Sell Stock

### Description
Say you have an array for which the ith element is the price of a given stock on day i.
If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.

**Example 1**
```
Input: [7, 1, 5, 3, 6, 4]
Output: 5

max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)
```
**Example 2**
```
Input: [7, 6, 4, 3, 1]
Output: 0

In this case, no transaction is done, i.e. max profit = 0.
```

**ç†è§£**
éœ€è¦ä¿å­˜çš„å€¼ä¸ºæœ€å°å€¼minå’Œæœ€å¤§å·®å€¼ï¼Œå¦‚æœå½“å‰å€¼å°äºminï¼Œåˆ™è¿›è¡Œæ›¿æ¢ï¼Œå¦‚æœå¤§äºå½“å‰å€¼ï¼Œåˆ™è¿›è¡Œç›¸å‡å¹¶æ¯”è¾ƒæœ€å¤§å·®å€¼ã€‚

[Solution](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/100-199/121_Best_time_Stock.py)

## 122 Best Time to Buy and Sell Stock II

### Description
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

**ç†è§£**

ä¸ä¸Šä¸€é¢˜ä¸åŒçš„æ˜¯ï¼Œè¿™é‡Œå¯ä»¥è¿›è¡Œå¤šæ¬¡ä¹°å–ï¼Œæ¥è¿›è¡Œæœ€å¤§çš„æ”¶ç›Šã€‚ä¸çœŸå®çš„è‚¡ç¥¨ä¹°å–ä¸åŒï¼Œè¿™é‡Œæ²¡æœ‰æœ¬é‡‘çš„æ¦‚å¿µï¼Œæ¯æ¬¡å‡ºå…¥ä¸€ä»½ï¼Œè€Œä¸”å…¥çš„æ—¶å€™é¡»ä¿è¯æ‰‹ä¸Šæ²¡æœ‰å…ƒç´ ã€‚

**æ€è€ƒ**

é€šç”¨ç®—æ³•ä¸ºï¼š
é€‰å–ä¸€ä¸ªmin å¦‚æœç¢°åˆ°æ›´å°åˆ™è¿›è¡Œæ›¿æ¢ï¼Œç¢°åˆ°å½“å‰å€¼ä¸‹ä¸€ä½æ˜¯å‡å°çš„æƒ…å†µä¸‹è¿›è¡Œå·®å€¼è®¡ç®—ï¼Œå¹¶ç´¯ç§¯è¿™ä¸ªå·®å€¼ã€‚
ç»è¿‡æ€è€ƒï¼Œæ›´æ–°ç®—æ³•ï¼š
ä¿å­˜ä¸€ä¸ªlowå€¼ï¼Œä¸€ä¸ªä¸ºhighå€¼ã€‚
å¦‚æœå½“å‰å…ƒç´ æ¯”lowå°ï¼Œåˆ™æ›¿æ¢lowï¼Œå¦‚æœå½“å‰å…ƒç´ æ¯”highå¤§åˆ™æ›¿æ¢highï¼Œå¦‚æœæ¯”highå°ï¼Œè¯´æ˜ä¸Šä¸€ä¸ªå€¼å·²ç»æ˜¯ä¸Šä¸ªé˜¶æ®µçš„æœ€å¤§å€¼ï¼Œæ­¤æ—¶è¿›è¡Œprofitè®¡ç®—ï¼Œå¹¶æŠŠlowä¸highå€¼èµ‹å€¼ä¸ºå½“å‰å€¼ã€‚

### å®ä¾‹
**[2,1,3,5,2,7]**

**[3,2,1]**

[Solution](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/100-199/122_Best_time_Stock_2.py)

## 125 Valid Palindrome

### Description
Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

For example,
**"A man, a plan, a canal: Panama"** is a palindrome.
**"race a car"** is not a palindrome.

**Note:**
Have you consider that the string might be empty? This is a good question to ask during an interview.

For the purpose of this problem, we define empty string as valid palindrome.

**æ€è€ƒ**

æ™®é€šçš„å›æ–‡é—®é¢˜ï¼Œéœ€è¦åšçš„æ˜¯å¿½ç•¥ç‰¹æ®Šå­—ç¬¦ï¼Œç„¶åä¸€å¤´ä¸€å°¾å›æ–‡åŒ¹é…ã€‚

[Solution](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/100-199/125_Valid_Palindrome.py)

## Single Number

### Description
Given an array of integers, every element appears twice except for one. Find that single one.

**Note:**
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

**æ€è€ƒ**

è¿™é‡Œæœ‰ä¸€ä¸ªè®¨å·§çš„æ–¹å¼ï¼Œxå¼‚æˆ–xä¸º0ï¼Œè€Œä»»ä½•æ•°å¼‚æˆ–0å¾—åˆ°æœ¬èº«ã€‚

## 141 Linked List Cycle

### Description
Given a linked list, determine if it has a cycle in it.

Follow up:
Can you solve it without using extra space?

**æ€è€ƒ**

å¸¸è§„ç®—æ³•ï¼š
è®¾å®šä¸¤ä¸ªæŒ‡é’ˆaä¸bï¼Œaæ¯èµ°ä¸€æ­¥bä»å¤´å¼€å§‹èµ°ï¼Œè‹¥b = a.next åˆ™è¯´æ˜æ­¤é“¾è¡¨æœ‰ç¯ã€‚è‹¥a = bè¯´æ˜è¿˜æ²¡æœ‰åˆ¤æ–­å‡ºæ˜¯å¦æœ‰ç¯ï¼Œaå†èµ°ä¸€æ­¥ï¼Œbä»å¤´å¼€å§‹ã€‚å½“a.next = None åˆ™è¯´æ˜æ­¤é“¾è¡¨æ²¡æœ‰ç¯ã€‚æ—¶é—´å¤æ‚åº¦ä¸º O(n^2)

æ”¹å–„ç‰ˆï¼š
åŒæ ·è®¾å®šä¸¤ä¸ªæŒ‡é’ˆaä¸bï¼Œaçš„é€Ÿåº¦ä¸ºbçš„ä¸¤å€ã€‚å¦‚æœè¿™ä¸ªé“¾è¡¨æœ‰ç¯...ä»–ä»¬æ€»æœ‰ä¸€å¤©ä¼šç›¸é‡çš„ğŸ˜³ã€‚æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ã€‚

## 144 Binary Tree Preorder Traversal

### Description

Given a binary tree, return the preorder traversal of its nodes' values.

**For example**:
Given binary tree {1,#,2,3},
```
   1
    \
     2
    /
   3
```
return **[1,2,3]**.

å‰åºéå†ï¼Œç”¨éé€’å½’çš„æ–¹å¼åšçš„å§ï¼Œéœ€è¦ä¸€ä¸ªè¾…åŠ©çš„æ ˆï¼Œä¿å­˜æ¯ä¸€ä¸ªæ ¹èŠ‚ç‚¹ã€‚ç„¶åå…ˆåˆ¤æ–­å·¦å­©å­ï¼Œæ²¡æœ‰çš„è¯ï¼Œæå–æ ˆé¡¶åˆ¤æ–­å³å­©å­ã€‚

[Solution](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/100-199/144_Binary_Tree_Preorder_Traversal.py)

## 155 Min Stack

### Description
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

* push(x) -- Push element x onto stack.
* pop() -- Removes the element on top of the stack.
* top() -- Get the top element.
* getMin() -- Retrieve the minimum element in the stack.

**Example**

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> Returns -3.
minStack.pop();
minStack.top();      --> Returns 0.
minStack.getMin();   --> Returns -2.
```
**æ€è€ƒ**

è¿™é‡Œéœ€è¦ç”¨stackæ¥è¿”å›æ ˆä¸­çš„æœ€å°å€¼ï¼Œå› ä¸ºå¦‚æœæ˜¯ç”¨intï¼Œä¸€æ—¦å½“å‰æœ€å°æ—¶popå‡ºå»ï¼Œæ— æ³•æ‰¾åˆ°ç¬¬äºŒå°çš„å…ƒç´ äº†ã€‚è¿˜æœ‰ä¸€ä¸ªè¦æ³¨æ„çš„åœ°æ–¹çš„æ˜¯ï¼Œpushä¸€ä¸ªç­‰äºminstack é¡¶éƒ¨çš„æ•°æ—¶ï¼Œä¹Ÿè¦æŠŠä»–pushè¿›min stackã€‚

## 160 Intersection of Two Linked Lists

### Description

Write a program to find the node at which the intersection of two singly linked lists begins.
For example, the following two linked lists:
```
A:          a1 â†’ a2
                   â†˜
                     c1 â†’ c2 â†’ c3
                   â†—            
B:     b1 â†’ b2 â†’ b3
```
begin to intersect at node c1.
**Notes:**
* If the two linked lists have no intersection at all, return null.
* The linked lists must retain their original structure after the function returns.
* You may assume there are no cycles anywhere in the entire linked structure.
* Your code should preferably run in O(n) time and use only O(1) memory.
**Credits:**
Special thanks to [@stellari](https://oj.leetcode.com/discuss/user/stellari) for adding this problem and creating all test cases.

**æ€è€ƒ**

åŸºç¡€æ€è·¯ï¼š
éå†ä¸¤æ¡é“¾è¡¨è®°å½•é•¿åº¦ï¼Œè®¡ç®—å·®å€¼ï¼Œç„¶åè®©é•¿çš„é‚£æ¡çº¿èµ°å‡ æ­¥ï¼ŒæŒ‡é’ˆç›¸åŒçš„æ—¶å€™å°±æ˜¯èŠ‚ç‚¹ã€‚å¦‚æœæœ«å°¾ä¸åŒå°±æ˜¯æ²¡æœ‰èŠ‚ç‚¹ã€‚

è¿›é˜¶æ€è·¯ï¼š
å½“æŒ‡é’ˆèµ°åˆ°æœ«å°¾çš„æ—¶å€™ï¼Œä»å¦ä¸€æ¡é“¾è¡¨çš„å¼€å¤´å¼€å§‹ç»§ç»­ç§»åŠ¨ï¼Œè¿™æ ·ä¼šå¯¼è‡´ä¸¤ç§æƒ…å†µï¼š
1. åœ¨èŠ‚ç‚¹å¤„ç›¸é‡
2. åŒæ—¶åˆ°è¾¾å¯¹æ–¹çš„æœ«å°¾
å› ä¸ºå®ƒä»¬èµ°è¿‡çš„è·¯ç¨‹æ˜¯ä¸€æ ·çš„ã€‚

## 167 Two Sum II - Input array is sorted

### Description

Given an array of integers that is already **sorted in ascending order**, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.

You may assume that each input would have exactly one solution and you may not use the same element twice.

**Input**: numbers={2, 7, 11, 15}, target=9
**Output**: index1=1, index2=2

**æ€è€ƒ**

è¿™ä¸ªé¢˜ç›®å¯ä»¥ç”¨æš´åŠ›ç®—æ³•æ¥æ±‚è§£çš„ï¼Œä½†æ˜¯åˆæ›´å¿§è§£ï¼Œæˆ‘çš„æƒ³æ³•æ˜¯ç”¨å“ˆå¸Œè¡¨ã€‚keyä¸ºéœ€è¦åŒ¹é…çš„æ•°ï¼ˆä¹Ÿå°±æ˜¯ tagartå‡å»æœ¬èº«ï¼‰ï¼Œvalueä¿å­˜è¿™ä¸ªå€¼çš„indexï¼ˆæ³¨æ„é¢˜ç›® è¾“å‡ºçš„indexæ¯”å®é™…å¤§1ï¼‰ã€‚è¿›è¡Œéå†ï¼Œå¦‚æœå½“å‰å€¼ä¸åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œåˆ™å»ºç«‹æ–°çš„ä¸€è¡Œã€‚å¦‚æœåœ¨å“ˆå¸Œè¡¨ä¸­æ‰¾åˆ°è¿™ä¸ªkeyï¼Œåˆ™è¾“å‡ºvalueå’Œè¿™ä¸ªæ•°åœ¨åˆ—è¡¨ä¸­çš„indexã€‚

## 168 Excel Sheet Column Title

### Description

Given a positive integer, return its corresponding column title as appear in an Excel sheet.

For example:
```
1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB
```
**æ€è€ƒ**

åè¿›åˆ¶å’Œ26è¿›åˆ¶çš„è½¬æ¢ã€‚æ³¨æ„è½¬æ¢ä¹‹åæ˜¯ä»Aå¼€å§‹çš„ï¼Œä¸æ˜¯é›¶ã€‚åœ¨æ±‚ä½™æ•°çš„æ—¶å€™æ³¨æ„è¦å‡å»1ã€‚ç„¶åç”¨ASCIIç è¿›è¡Œè½¬æ¢ã€‚

## 169 Majority Element

### Description
Given an array of size n, find the majority element. The majority element is the element that appears **more than** âŒŠ n/2 âŒ‹ times.

You may assume that the array is non-empty and the majority element always exist in the array.

**Credits**:
Special thanks to [@ts](https://oj.leetcode.com/discuss/user/ts) for adding this problem and creating all test cases.

ç”¨å“ˆå¸Œè¡¨ä¿å­˜æ•°å­—çš„è®¡æ•°ã€‚

## 171 Excel Sheet Column Number

### Description

Given a column title as appear in an Excel sheet, return its corresponding column number.

For example:
```
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28
```

## 172 Factorial Trailing Zeroes

### Description

Given an integer n, return the number of trailing zeroes in n!.

**Note**: Your solution should be in logarithmic time complexity.

æ•°5çš„ä¸ªæ•°ã€‚

## 189 Rotate Array

### Description

Rotate an array of n elements to the right by k steps.

For example, with n = 7 and k = 3, the array **[1,2,3,4,5,6,7]** is rotated to **[5,6,7,1,2,3,4]**.

**Note**:
Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.

## 190 Reverse Bits

### Description

Reverse bits of a given 32 bits unsigned integer.

For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).

## 191 Number of 1 Bits

### Description

Write a function that takes an unsigned integer and returns the number of â€™1' bits it has (also known as the Hamming weight).

For example, the 32-bit integer â€™11' has binary representation 00000000000000000000000000001011, so the function should return 3.

Hamming Weight æœ‰å¥½å¤šä¸­ç®—æ³•ã€‚å…·ä½“å¹¶æ²¡æœ‰ç ”ç©¶ã€‚ æ™®é€šçš„ä½æ“ä½œå¹¶ä¸èƒ½é€šè¿‡æ•ˆç‡æ£€æµ‹ã€‚

## 202 Happy Number

### Description

Write an algorithm to determine if a number is "happy".

A happy number is a number defined by the following process: Starting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy numbers.

Example: 19 is a happy number

1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1

**æ€è€ƒ**
å¦‚æœä¸æ˜¯å¼€å¿ƒæ•°ï¼Œé‚£ä¹ˆè®¡ç®—çš„sumä¸€å®šæ˜¯ä¸€ä¸ªå¾ªç¯ã€‚å»ºç«‹ä¸€ä¸ªstackï¼Œå­˜æ”¾è®¡ç®—å‡ºçš„sumï¼Œä¸€æ—¦æ–°è®¡ç®—å‡ºæ¥çš„sumå·²ç»åœ¨stackä¸­ï¼Œåˆ™è¯´æ˜è¿™ä¸ªæ•°ä¸æ˜¯å¼€å¿ƒæ•°ã€‚åä¹‹ï¼Œä¸€æ—¦sumä¸º1ï¼Œ é‚£ä¹ˆè¿™ä¸ªæ•°ä¸ºå¼€å¿ƒæ•°ã€‚

## 203 Remove Linked List Elements

### Description

Remove all elements from a linked list of integers that have value val.

Example
Given: 1 --> 2 --> 6 --> 3 --> 4 --> 5 --> 6, val = 6
Return: 1 --> 2 --> 3 --> 4 --> 5

ç®€å•çš„å•å‘é“¾è¡¨å…ƒç´ åˆ é™¤ï¼Œå¯¹äºé“¾è¡¨å¤´çš„åˆ é™¤ï¼Œæ˜¯ä¸€ç§ç‰¹ä¾‹ï¼Œå¯ä»¥ä¸ºé“¾è¡¨å¤´å‰åŠ ä¸€ä¸ªè¾…åŠ©çš„èŠ‚ç‚¹ï¼Œæ•°å€¼ä»»æ„ï¼Œæœ€åè¿”å›çš„å€¼æ˜¯head.next,ä¹Ÿå°±æ˜¯å»é™¤è¾…åŠ©èŠ‚ç‚¹ã€‚è€Œå¯¹äºåˆ é™¤æ¥è¯´éœ€è¦åšçš„æ˜¯è®¾å®šä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€å‰ä¸€åã€‚å½“åæŒ‡é’ˆçš„å€¼ç­‰äºvalï¼Œåˆ™å‰æŒ‡é’ˆçš„nextç­‰äºåæŒ‡é’ˆçš„nextã€‚


## 204 Count Primes

### Description

Description:

Count the number of prime numbers less than a non-negative number, n.

è¿™é‡Œæœ‰å¥½å¤šè§£æ³•ã€‚æ™®é€šç®—æ³•çš„æ—¶é—´å¤æ‚åº¦å¾ˆé«˜ï¼Œè¿˜æœ‰ä¸€ä¸ªç§ç®—æ³•å«åš[åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³•](https://en.wikipedia.org/wiki/Sieve_of_Eratosthenes)ã€‚ä½†æ˜¯ç”¨è¿™ç§ç­›é€‰æ³•ç”¨pythonæ¥å®ç°åœ¨leetcodeä¸Šæœ‰TLEé—®é¢˜çš„ã€‚ç­”æ¡ˆç§æä¾›äº†å¦å¤–ä¸€ç§ä¼˜åŒ–ã€‚å¯ä»¥çœ‹ä¸€ä¸‹ã€‚

## 205 Isomorphic Strings

### Description

Given two strings s and t, determine if they are isomorphic.

Two strings are isomorphic if the characters in s can be replaced to get t.

All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.

For example,
Given **"egg"**, **"add"**, return true.

Given **"foo"**, **"bar"**, return false.

Given **"paper"**, **"title"**, return true.

è¿™é‡Œä¸éœ€è¦åšæ›¿æ¢ã€‚åªéœ€è¦å»ºç«‹çš„hashè¡¨ï¼Œçœ‹æ¯ä¸€ä¸ªå­—ç¬¦æ˜¯å¦æœ‰å¯¹åº”ã€‚éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œä¸ä»…keyçš„å€¼æ˜¯å”¯ä¸€çš„ï¼Œä¹Ÿè¦æ³¨æ„valueçš„å€¼ä¹Ÿæ˜¯è¦å”¯ä¸€çš„ã€‚

## 206 Reverse Linked List

### Description

Reverse a singly linked list.

solution ç”¨äº†é€’å½’çš„æ€æƒ³ã€‚éœ€è¦åŠ å¼ºè¿™æ–¹é¢çš„æ€æƒ³ã€‚

## 217 Contains Duplicate

### Description

Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.

ç”¨å“ˆå¸Œè¡¨çš„æ–¹å¼ä¼šTLEï¼Œæ‰€ä»¥ä½¿ç”¨äº†å…ˆæ’åºåæ¯”è¾ƒå‰åå€¼ï¼Œå¤æ‚å°±ä¾èµ–äºæ’åºç®—æ³•äº†ã€‚

## 219 Contains Duplicate II

### Description 

Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that **nums[i]** = **nums[j]** and the **absolute** difference between i and j is at most k.

ç”¨å“ˆå¸Œè¡¨æ¥å‚¨å­˜indexï¼Œå¦‚æœå·²ç»å­˜åœ¨åˆ™è¿›è¡Œæ¯”è¾ƒã€‚å¦‚æœå°äºkï¼Œåˆ™è¿”å›Trueï¼Œåä¹‹è¦†ç›–åŸæ¥çš„indexã€‚

## 225 Implement Stack using Queues

### Description

Implement the following operations of a stack using queues.

push(x) -- Push element x onto stack.
pop() -- Removes the element on top of the stack.
top() -- Get the top element.
empty() -- Return whether the stack is empty.
**Notes:**
You must use only standard operations of a queue -- which means only push to back, peek/pop from front, size, and is empty operations are valid.
Depending on your language, queue may not be supported natively. You may simulate a queue by using a list or deque (double-ended queue), as long as you use only standard operations of a queue.
You may assume that all operations are valid (for example, no pop or top operations will be called on an empty stack).

å¯ä»¥ä½¿ç”¨åŒç«¯é˜Ÿåˆ—å°±å¾ˆç®€å•å•¦ã€‚pythonåˆå§‹åŒç«¯é˜Ÿåˆ—çš„æ–¹å¼è¦çŸ¥é“ã€‚

## 226 Invert Binary Tree

### Description

Invert a binary tree.
```

     4
   /   \
  2     7
 / \   / \
1   3 6   9
to
     4
   /   \
  7     2
 / \   / \
9   6 3   1
```

å¸¸è§„æ€è·¯å°±æ˜¯é€’å½’ã€‚åŒæ ·ä¹Ÿå¯ä»¥ä½¿ç”¨æ ˆçš„æ–¹å¼å»å®ç°ã€‚

## 231 Power of Two

### Description

Given an integer, write a function to determine if it is a power of two.

ä¾æ—§å¯ä»¥ä½¿ç”¨é€’å½’æ€æƒ³ã€‚è¿˜æœ‰ä¸€ç§å·§å¦™çš„æ–¹å¼ï¼šå¦‚æœ nä¸º2çš„æ¬¡æ–¹ï¼Œé‚£ä¹ˆäºŒè¿›åˆ¶ nä¸n-1 ä¸º 0.

## 232 Implement Queue using Stacks

### Description

Implement the following operations of a queue using stacks.

- push(x) -- Push element x to the back of queue.
- pop() -- Removes the element from in front of queue.
- peek() -- Get the front element.
- empty() -- Return whether the queue is empty.

**Notes:**

- You must use only standard operations of a stack -- which means only push to top, peek/pop from top, size, and is empty operations are valid.
- Depending on your language, stack may not be supported natively. You may simulate a stack by using a list or deque (double-ended queue), as long as you use only standard operations of a stack.
- You may assume that all operations are valid (for example, no pop or peek operations will be called on an empty queue).

## 234 Palindrome Linked List

### Description

Given a singly linked list, determine if it is a palindrome.

Follow up:
Could you do it in O(n) time and O(1) space?

**æ€è€ƒ**
å•å‘é“¾è¡¨æŸ¥æ‰¾çˆ¶çº§å…ƒç´ æ¯”è¾ƒå¤æ‚ã€‚å¯ä»¥é€‰æ‹©listæ¥å‚¨å­˜å€¼æ¥è¿›è¡Œæ¯”è¾ƒã€‚ä¸€ç§æ˜¯å…¨éƒ¨å‚¨å­˜åˆ°listï¼Œè¿™æ ·çš„ç©ºé—´å¤æ‚åº¦ä¸ºO(n)ï¼Œä¸€ç§æ˜¯å­˜å‚¨ä¸€åŠï¼Œç”¨é“¾è¡¨å’Œlistè¿›è¡Œæ¯”è¾ƒã€‚ç©ºé—´å¤æ‚åº¦ä¸º(n/2)ã€‚è¿™é‡Œæä¾›ä¸€ä¸ªæ‰¾åˆ°ä¸­ç‚¹çš„æ–¹å¼ï¼šè®¾ç½®ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªæŒ‡é’ˆæ¯æ¬¡èµ°ä¸€ä½ï¼Œä¸€ä¸ªæŒ‡é’ˆä¸€æ¬¡èµ°ä¸¤ä½ï¼Œå½“å¿«çš„æŒ‡é’ˆåˆ°å°¾ç«¯æ—¶ï¼Œæ…¢çš„æŒ‡é’ˆåœ¨ä¸­ç‚¹ã€‚å¯¹ä¸é¢˜ç›®ä¸­çš„follow upï¼Œ ç©ºé—´å¤æ‚åº¦ä¸ºO(1)ï¼Œé‚£ä¹ˆåªèƒ½ç”¨åˆ°æŒ‡é’ˆäº†ã€‚åšæ³•æ˜¯å°†ååŠæ®µé€†åºå¤„ç†ï¼Œç„¶åé€ä¸€æ¯”è¾ƒã€‚

## 235 Lowest Common Ancestor of a Binary Search Tree

### Description

Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

According to the [definition of LCA on Wikipedia](https://en.wikipedia.org/wiki/Lowest_common_ancestor): â€œThe lowest common ancestor is defined between two nodes v and w as the lowest node in T that has both v and w as descendants (where we allow **a node to be a descendant of itself**).â€

```
        _______6______
       /              \
    ___2__          ___8__
   /      \        /      \
   0      _4       7       9
         /  \
         3   5
```

For example, the lowest common ancestor (LCA) of nodes 2 and 8 is 6. Another example is LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.

**æ€è€ƒ** 

å› ä¸ºæ˜¯äºŒå‰æœç´¢æ ‘ï¼Œæ‰€ä»¥åªéœ€è¦æ¯”è¾ƒvalï¼Œpï¼Œqåœ¨nodeå¼‚ä¾§åˆ™è¯´æ˜nodeä¸ºå…¬å…±ç¥–å…ˆã€‚

## 237 Delete Node in a Linked List

### Description

Write a function to delete a node (except the tail) in a singly linked list, given only access to that node.

Supposed the linked list is 1 -> 2 -> 3 -> 4 and you are given the third node with value 3, the linked list should become 1 -> 2 -> 4 after calling your function.

## 242 Valid Anagram

### Description

Given two strings s and t, write a function to determine if t is an anagram of s.

For example,
s = "anagram", t = "nagaram", return true.
s = "rat", t = "car", return false.

Note:
You may assume the string contains only lowercase alphabets.

Follow up:
What if the inputs contain unicode characters? How would you adapt your solution to such case?

è½¬åŒ–æˆlistï¼Œæ’åºå†è¿›è¡Œæ¯”å¯¹ã€‚

## 258 Add Digits

### Description

Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.

For example:

Given num = 38, the process is like: 3 + 8 = 11, 1 + 1 = 2. Since 2 has only one digit, return it.

**Follow up**:
Could you do it without any loop/recursion in O(1) runtime?

O(1) Algorithms: return (num -1) % 9 + 1

## 263 Ugly Number

### Description

Write a program to check whether a given number is an ugly number.

Ugly numbers are positive numbers whose prime factors only include 2, 3, 5. For example, 6, 8 are ugly while 14 is not ugly since it includes another prime factor 7.

Note that 1 is typically treated as an ugly number.

## 278 First Bad Version

### Description

You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.

Suppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.

You are given an API bool isBadVersion(version) which will return whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.

äºŒåˆ†æŸ¥æ‰¾

## 283 Move Zeros

### Description

Given an array nums, write a function to move all 0's to the end of it while maintaining the relative order of the non-zero elements.

For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].

Note:
You must do this in-place without making a copy of the array.
Minimize the total number of operations.

è®¾ç½®ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªä¸ºå¸¸æŒ‡é’ˆï¼Œéå†æ•´ä¸ªlistï¼Œå¸¸æŒ‡é’ˆæ‰¾åˆ°ä¸€ä¸ªéé›¶æ•°ï¼Œåˆ™è¿›è¡Œèµ‹å€¼å¹¶æŒ‡å‘åä¸€ä½ã€‚

## 290 Word Pattern

### Description

Given a pattern and a string str, find if str follows the same pattern.

Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in str.

**Examples:**
- pattern = "abba", str = "dog cat cat dog" should return true.
- pattern = "abba", str = "dog cat cat fish" should return false.
- pattern = "aaaa", str = "dog cat cat dog" should return false.
- pattern = "abba", str = "dog dog dog dog" should return false.
**Notes:**
You may assume pattern contains only lowercase letters, and str contains lowercase letters separated by a single space.

## 292 Nim Game

### Description

You are playing the following Nim Game with your friend: There is a heap of stones on the table, each time one of you take turns to remove 1 to 3 stones. The one who removes the last stone will be the winner. You will take the first turn to remove the stones.

Both of you are very clever and have optimal strategies for the game. Write a function to determine whether you can win the game given the number of stones in the heap.

For example, if there are 4 stones in the heap, then you will never win the game: no matter 1, 2, or 3 stones you remove, the last stone will always be removed by your friend.

åªè¦ä¸æ˜¯4çš„å€æ•°å°±èƒ½èµ¢ã€‚ã€‚


## 303 Range Sum Query - Immutable

### Description

Given an integer array nums, find the sum of the elements between indices i and j (i â‰¤ j), inclusive.

**Example:**

Given nums = [-2, 0, 3, -5, 2, -1]

sumRange(0, 2) -> 1
sumRange(2, 5) -> -1
sumRange(0, 5) -> -3

**Note:**

1. You may assume that the array does not change.
2. There are many calls to sumRange function.

ä¸ºäº†é˜²æ­¢TLEï¼Œåœ¨åˆå§‹objectçš„æ—¶å€™ï¼Œè®¡ç®—å‡ºå‰nä¸ªæ•°çš„å’Œï¼Œè¿™æ ·åœ¨è°ƒç”¨çš„æ—¶å€™ï¼Œå¯ä»¥åˆ©ç”¨å‡æ³•ç›´æ¥å¾—å‡ºç»“è®ºã€‚

## 326 Power of Three

Given an integer, write a function to determine if it is a power of three.

Follow up:
Could you do it without using any loop / recursion?

æ–¹æ³•ä¸€ï¼šæ•°å­¦æ–¹æ³•ï¼Œ x = log(n)/log(3)
æ–¹æ³•äºŒï¼šåˆ©ç”¨è®¡ç®—æœºçš„ç‰¹æ€§ï¼Œç®—å‡ºfloatèŒƒå›´ä¸­ï¼Œæœ€å¤§çš„3çš„å€æ•°å¹‚æ•°ã€‚

## 342 Power of Four

### Description

Given an integer (signed 32 bits), write a function to check whether it is a power of 4.

Example:
Given num = 16, return true. Given num = 5, return false.

Follow up: Could you solve it without loops/recursion?

è¿›è¡Œä½è¿ç®—ã€‚åˆ¤æ–­1æ˜¯ä¸æ˜¯åœ¨å¥‡æ•°ä½ã€‚

## 344 Reverse String

### Description

Write a function that takes a string as input and returns the string reversed.

**Example**:
Given s = "hello", return "olleh".

## 345 Reverse Vowels of a String

### Description

Write a function that takes a string as input and reverse only the vowels of a string.

**Example 1**:
Given s = "hello", return "holle".

**Example 2**:
Given s = "leetcode", return "leotcede".

**Note**:
The vowels does not include the letter "y".


## 349 Intersection of Two Arrays

### Description

Given two arrays, write a function to compute their intersection.

**Example**:
Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2].

**Note**:
* Each element in the result must be unique.
* The result can be in any order.

è¿™é‡Œæ±‚çš„æ˜¯é›†åˆï¼Œå¹¶ä¸æ˜¯åŒ¹é…åˆ—è¡¨å‘¢ã€‚pythonæœ‰é›†åˆå¤„ç†çš„functionï¼Œä½¿ç”¨setæŠŠåˆ—è¡¨è½¬æ¢æˆé›†ï¼Œç„¶åè¿›è¡Œé€»è¾‘è¿ç®—ã€‚

## 350 Intersection of Two Arrays

### Description

Given two arrays, write a function to compute their intersection.

**Example**:
Given nums1 = [1, 2, 2, 1], nums2 = [2, 2], return [2, 2].

**Note**:

Each element in the result should appear as many times as it shows in both arrays.
The result can be in any order.
**Follow up**:
* What if the given array is already sorted? How would you optimize your algorithm?
* What if nums1's size is small compared to nums2's size? Which algorithm is better?
* What if elements of nums2 are stored on disk, and the memory is limited such that you cannot load all elements into the * * memory at once?

æ•°ç»„å…ƒç´ è®¡æ•°çš„é—®é¢˜ï¼Œéƒ½æ¯”è¾ƒæ¨èç”¨å“ˆå¸Œè¡¨å»è®¡æ•°ã€‚

## 367 Valid Perfect Square

### Description

Given a positive integer num, write a function which returns True if num is a perfect square else False.

Note: Do not use any built-in library function such as sqrt.

**Example 1**:
```
Input: 16
Returns: True
```
**Example 2**:
```
Input: 14
Returns: False
```

å¯ä»¥ç”¨äºŒåˆ†æŸ¥æ‰¾ã€‚O(lgN)

## 371 Sum of Two Integers

### Description

Calculate the sum of two integers a and b, but you are **not allowed** to use the operator + and -.

**Example**:
Given a = 1 and b = 2, return 3.

åˆ©ç”¨ä½è¿ç®—è¿›è¡ŒåŠ æ³•è¿ç®—ï¼Œpythonæ²¡èƒ½å®ç°ï¼Œç”¨äº†c++ã€‚

## 374 Guess Number Higher or Lower

### Description

We are playing the Guess Game. The game is as follows:

I pick a number from 1 to n. You have to guess which number I picked.

Every time you guess wrong, I'll tell you whether the number is higher or lower.

You call a pre-defined API guess(int num) which returns 3 possible results (-1, 1, or 0):
```
-1 : My number is lower
 1 : My number is higher
 0 : Congrats! You got it!
 ```
**Example**:
```
n = 10, I pick 6.

Return 6.
```

åˆ©ç”¨äºŒåˆ†æŸ¥æ‰¾çŒœæµ‹æ•°å­—å¤§å°ã€‚

## 383 Ransom Note

### Description

Given an arbitrary ransom note string and another string containing letters from all the magazines, write a function that will return true if the ransom note can be constructed from the magazines ; otherwise, it will return false.

Each letter in the magazine string can only be used once in your ransom note.

Note:
You may assume that both strings contain only lowercase letters.
```
canConstruct("a", "b") -> false
canConstruct("aa", "ab") -> false
canConstruct("aa", "aab") -> true
```

ç”¨å“ˆå¸Œè¡¨è®°å½•å­—æ¯å‡ºç°çš„æ¬¡æ•°ï¼Œè¿›è¡ŒéªŒè¯ã€‚

## 387 First Unique Character in a String

### Description

Given a string, find the first non-repeating character in it and return it's index. If it doesn't exist, return -1.

**Examples**:
```
s = "leetcode"
return 0.

s = "loveleetcode",
return 2.
```
**Note**: You may assume the string contain only lowercase letters.

ç”¨äº†å“ˆå¸Œè¡¨è®¡æ•°ï¼Œæ›´å¥½çš„æ–¹å¼æ˜¯ï¼šç›´æ¥è®¡ç®—å‡ºç°çš„æ¬¡æ•°å¹¶ç”Ÿæˆåˆ—è¡¨ã€‚

```
index=[s.index(l) for l in letters if s.count(l) == 1]
```

## 389 Find the Difference

### Description

Given two strings s and t which consist of only lowercase letters.

String t is generated by random shuffling string s and then add one more letter at a random position.

Find the letter that was added in t.

**Example**:
```
Input:
s = "abcd"
t = "abcde"

Output:
e

Explanation:
'e' is the letter that was added.
```

å› ä¸ºtç›¸è¾ƒäºså¤šäº†ä¸€ä¸ªå­—ç¬¦ï¼Œè¿”å›çš„ä¹Ÿæ˜¯å­—ç¬¦ï¼Œå¯ä»¥å¯¹sï¼Œtè¿›è¡Œæ’åºï¼Œç„¶åé€ä¸€æ¯”è¾ƒï¼Œç¬¬ä¸€ä¸ªä¸åŒçš„å…ƒç´ æ˜¯è¢«æŸ¥æ‰¾çš„æ•°å­—ã€‚

## Nth Digit

### Description

Find the nth digit of the infinite integer sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ...

**Note**:
n is positive and will fit within the range of a 32-bit signed integer (n < 231).

**Example 1**:
```
Input:
3

Output:
3
```
**Example 2**:
```
Input:
11

Output:
0

Explanation:
The 11th digit of the sequence 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, ... is a 0, which is part of the number 10.
```

è¦æ³¨æ„nçš„èµ·å§‹å€¼ã€‚

## 401 Binary Watch

### Description

A binary watch has 4 LEDs on the top which represent the hours (0-11), and the 6 LEDs on the bottom represent the minutes (0-59).

Each LED represents a zero or one, with the least significant bit on the right.

Given a non-negative integer n which represents the number of LEDs that are currently on, return all possible times the watch could represent.

**Example**:
```
Input: n = 1
Return: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]
```
**Note**:
* The order of output does not matter.
* The hour must not contain a leading zero, for example "01:00" is not valid, it should be "1:00".
* The minute must be consist of two digits and may contain a leading zero, for example "10:2" is not valid, it should be "10:02".

åœ¨éå†çš„å¯èƒ½æ€§å°çš„æƒ…å†µä¸‹ï¼Œå¯ä»¥é€‰æ‹©æšä¸¾æ¯”è¾ƒï¼Œç¬¦åˆæ¡ä»¶çš„å…¥æ ˆã€‚è¿™é‡Œéœ€è¦æŒæ¡çš„æ˜¯bin()å‡½æ•°ï¼Œè½¬æ¢æ•°å­—ä¸ºäºŒè¿›åˆ¶stringï¼Œå·²ç»count()æ•°stringä¸­charçš„æ•°é‡ã€‚

## 404 Sum of Left Leaves

### Description

Find the sum of all left leaves in a given binary tree.

**Example**:
```
    3
   / \
  9  20
    /  \
   15   7

There are two left leaves in the binary tree, with values 9 and 15 respectively. Return 24.
```

## Convert a Number to Hexadecimal

### Description

Given an integer, write an algorithm to convert it to hexadecimal. For negative integer, twoâ€™s complement method is used.

**Note**:

1. All letters in hexadecimal (a-f) must be in lowercase.
2. The hexadecimal string must not contain extra leading 0s. If the number is zero, it is represented by a single zero character '0'; otherwise, the first character in the hexadecimal string will not be the zero character.
3. The given number is guaranteed to fit within the range of a 32-bit signed integer.
4. You must not use any method provided by the library which converts/formats the number to hex directly.
**Example 1**:
```
Input:
26

Output:
"1a"
```
Example 2:
```
Input:
-1

Output:
"ffffffff"
```

æœ‰å…³2è¿›åˆ¶çš„é—®é¢˜éƒ½å¯ä»¥è¯•ç€è€ƒè™‘ä½è¿ç®—ã€‚

## 409 Longest Palindrome

### Description

Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.

This is case sensitive, for example "Aa" is not considered a palindrome here.

**Note**:
Assume the length of given string will not exceed 1,010.

**Example**:
```
Input:
"abccccdd"

Output:
7

Explanation:
One longest palindrome that can be built is "dccaccd", whose length is 7.
```

æˆ‘ç”¨çš„æ˜¯å“ˆå¸Œè¡¨è®¡æ•°ï¼Œç„¶åæœ€åè¿›è¡Œç´¯åŠ ï¼ŒæŸä¸€charæ˜¯å•æ•°çš„è¯å°±-1ï¼Œå¦‚æœå­˜åœ¨å•æ•°çš„è¯ï¼Œç´¯è®¡ä¸€æ¬¡ã€‚
åœ¨ç­”æ¡ˆä¸­ï¼Œæä¾›äº†ä¸€ä¸ªç½‘ä¸Šçš„è®¨è®ºï¼Œæ›´åŠ ç®€æ´ã€‚ç›´æ¥æ•°å‡ºç°å¥‡æ•°æ¬¡çš„å…ƒç´ çš„ä¸ªæ•°ï¼Œå†ä»æ€»é•¿ä¸­å‡å»è¿™ä¸ªå€¼ï¼Œå¦‚æœå­˜åœ¨å¥‡æ•°æ¬¡æ•°çš„å…ƒç´ ï¼Œæœ€ååŠ 1.

## Fizz Buzz

### Description

Write a program that outputs the string representation of numbers from 1 to n.

But for multiples of three it should output â€œFizzâ€ instead of the number and for the multiples of five output â€œBuzzâ€. For numbers which are multiples of both three and five output â€œFizzBuzzâ€.

**Example**:
```
n = 15,

Return:
[
    "1",
    "2",
    "Fizz",
    "4",
    "Buzz",
    "Fizz",
    "7",
    "8",
    "Fizz",
    "Buzz",
    "11",
    "Fizz",
    "13",
    "14",
    "FizzBuzz"
]
```

å†™å¯¹åˆ¤æ–­æ¡ä»¶å°±å¥½å•¦ã€‚

## 414 Third Maximum Number

### Description

Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).

**Example 1**:
```
Input: [3, 2, 1]

Output: 1

Explanation: The third maximum is 1.
```
**Example 2**:
```
Input: [1, 2]

Output: 2

Explanation: The third maximum does not exist, so the maximum (2) is returned instead.
```
**Example 3**:
```
Input: [2, 2, 3, 1]

Output: 1

Explanation: Note that the third maximum here means the third maximum distinct number.
Both numbers with value 2 are both considered as second maximum.
```

è®¾ä¸€ä¸ªlistä¿å­˜æœ€å¤§çš„ä¸‰ä¸ªæ•°ï¼Œåœ¨æ›¿æ¢listçš„å€¼çš„æ—¶å€™ï¼Œæ³¨æ„åˆ¤æ–­æ˜¯å¦å·²ç»å­˜åœ¨è¿™ä¸ªæ•°ã€‚

## 415 Add String

### Description

Given two non-negative integers num1 and num2 represented as string, return the sum of num1 and num2.

**Note**:

1. The length of both num1 and num2 is < 5100.
2. Both num1 and num2 contains only digits 0-9.
3. Both num1 and num2 does not contain any leading zero.
4. You must not use any built-in BigInteger library or convert the inputs to integer directly.

è®¡ç®—çš„æ—¶å€™åˆ«å¿˜è®°è¿›ä½ã€‚

## 434 Number of Segments in a String

### Description

Count the number of segments in a string, where a segment is defined to be a contiguous sequence of non-space characters.

Please note that the string does not contain any non-printable characters.

**Example**:
```
Input: "Hello, my name is John"
Output: 5
```

åœ¨pythonä¸­ï¼Œå°±æ˜¯åˆ†å‰²stringï¼Œå†è¿”å›listçš„é•¿åº¦ã€‚

## 441 Arranging Coins

### Description

You have a total of n coins that you want to form in a staircase shape, where every k-th row must have exactly k coins.

Given n, find the total number of full staircase rows that can be formed.

n is a non-negative integer and fits within the range of a 32-bit signed integer.

**Example 1**:
```
n = 5

The coins can form the following rows:
Â¤
Â¤ Â¤
Â¤ Â¤

Because the 3rd row is incomplete, we return 2.
```
**Example 2**:
```
n = 8

The coins can form the following rows:
Â¤
Â¤ Â¤
Â¤ Â¤ Â¤
Â¤ Â¤

Because the 4th row is incomplete, we return 3.
```

åœ¨é€æ­¥é€¼è¿‘æŸ¥æ‰¾ç»ˆå€¼çš„æ—¶å€™ï¼Œè€ƒè™‘äºŒåˆ†æŸ¥æ‰¾ï¼Œæ³¨æ„åˆ¤æ–­æ¡ä»¶ã€‚

## 447 Number of Boomerangs

### Description

Given n points in the plane that are all pairwise distinct, a "boomerang" is a tuple of points (i, j, k) such that the distance between i and j equals the distance between i and k (**the order of the tuple matters**).

Find the number of boomerangs. You may assume that n will be at most **500** and coordinates of points are all in the range **[-10000, 10000]** (inclusive).

**Example:**
```
Input:
[[0,0],[1,0],[2,0]]

Output:
2

Explanation:
The two boomerangs are [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]]
```

å¸¸è§„æ€è·¯æ˜¯å–ä¸‰ä¸ªå€¼ï¼Œè¿›è¡Œæ¯”è¾ƒï¼Œè·ç¦»ç›¸ç­‰åˆ™ç´¯åŠ ï¼Œè¿™æ ·çš„æ—¶é—´å¤æ‚åº¦æ˜¯O(n^3)ï¼Œåœ¨åˆ·äº†è¿™ä¹ˆå¤šçš„é¢˜ä¹‹åï¼Œè§‰å¾—ä½¿ç”¨hashè¡¨çš„æ–¹å¼ï¼Œå¯ä»¥é™ä½ä¸€çº§å¤æ‚åº¦ï¼Œè¿™é‡Œçš„solutionä¹Ÿç”¨åˆ°äº†å“ˆå¸Œè¡¨ï¼š
1. å–ä¸€ä¸ªç‚¹iï¼Œå¹¶å»ºç«‹ä¸€ä¸ªç©ºçš„å“ˆå¸Œè¡¨ï¼Œå¼€å§‹å–ç¬¬äºŒä¸ªç‚¹j
2. å“ˆå¸Œè¡¨çš„ç»“æ„ä¸ºï¼šjåˆ°içš„è·ç¦»=>ä¸è¿™ä¸ªè·ç¦»ä¸€æ ·çš„jç‚¹çš„æ•°é‡
3. æ‰€æœ‰ç‰¹å®šè·ç¦»çš„jç‚¹çš„æ’åˆ—ç»„åˆ

## 448 Find All Numbers Disappeared in an Array

## Description

Given an array of integers where 1 â‰¤ a[i] â‰¤ n (n = size of array), some elements appear twice and others appear once.

Find all the elements of [1, n] inclusive that do not appear in this array.

Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.

Example:
```
Input:
[4,3,2,7,8,2,3,1]

Output:
[5,6]
```

æ€è·¯ï¼šéå†æ•°ç»„ï¼Œå½“å‰æ•°xï¼Œå°†ä½ç½®ä¸ºx-1çš„æ•°å˜ä¸ºè´Ÿæ•°ï¼Œæ„æ€ä¸ºï¼šå¦‚æœä½ç½®x-1ä¸ºè´Ÿæ•°ï¼Œé‚£ä¹ˆè¿™ä¸ªæ•°å·²ç»å‡ºç°è¿‡ã€‚æœ€åå†æ¬¡éå†æ•°ç»„ï¼Œå°†æ­£æ•°çš„ä½ç½®æ‰¾å‡ºã€‚

## 453 Minimum Moves to Equal Array Elements

### Description

Given a non-empty integer array of size n, find the minimum number of moves required to make all array elements equal, where a move is incrementing n - 1 elements by 1.

**Example**:
```
Input:
[1,2,3]

Output:
3

Explanation:
Only three moves are needed (remember each move increments two elements):

[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]
```

æ¯æ¬¡å˜åŠ¨n-1ä¸ªå…ƒç´ ï¼Œå¢åŠ 1ï¼Œç›¸å½“äºä¸€ä¸ªå…ƒç´ å‡å»1ï¼Œé‚£ä¹ˆè®©å…¶ä»–å…ƒç´ ç­‰äºæœ€å°å€¼å°±å¯ä»¥ã€‚

## 455 Assign Cookies

### Description

Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor gi, which is the minimum size of a cookie that the child will be content with; and each cookie j has a size sj. If sj >= gi, we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.

**Note**:
You may assume the greed factor is always positive. 
You cannot assign more than one cookie to one child.

**Example 1:**
```
Input: [1,2,3], [1,1]

Output: 1

Explanation: You have 3 children and 2 cookies. The greed factors of 3 children are 1, 2, 3. 
And even though you have 2 cookies, since their size is both 1, you could only make the child whose greed factor is 1 content.
You need to output 1.
```
**Example 2:**
```
Input: [1,2], [1,2,3]

Output: 2

Explanation: You have 2 children and 3 cookies. The greed factors of 2 children are 1, 2. 
You have 3 cookies and their sizes are big enough to gratify all of the children, 
You need to output 2.
```

æ’åºï¼Œè®©æœ€å°sizeçš„cookieå»åŒ¹é…greedã€‚

## 459 Repeated Substring Pattern

### Description

Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.

**Example 1:**
```
Input: "abab"

Output: True

Explanation: It's the substring "ab" twice.
```
**Example 2:**
```
Input: "aba"

Output: False
```
**Example 3:**
```
Input: "abcabcabcabc"

Output: True

Explanation: It's the substring "abc" four times. (And the substring "abcabc" twice.)
```

å¦‚æœæ»¡è¶³æ¡ä»¶ï¼Œé‚£ä¹ˆè¢«æˆªå–çš„å­—ç¬¦ä¸²æ˜¯åŸå­—ç¬¦ä¸²é•¿åº¦çš„çº¦æ•°ã€‚ç”Ÿæˆä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²ï¼šè¢«æˆªå–çš„å­—ç¬¦ä¸²å¤åˆ¶næ¬¡ï¼Œå¦‚æœå’ŒåŸå­—ç¬¦ä¸²ç›¸ç­‰ï¼Œé‚£ä¹ˆè¿”å›å€¼ä¸ºTrueã€‚
























