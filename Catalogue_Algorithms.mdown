# Catalogue

## 1 Two Sum

### Description
Given an array of integers, return **indices** of the two numbers such that they add up to a specific target.
You may assume that each input would have **exactly** one solution, and you may not use the same element twice.

**Example**


>Given nums = [2, 7, 11, 15], target = 9,
>
>Because nums[0] + nums[1] = 2 + 7 = 9,
>return [0, 1].


Result:[Two Sum](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/twoSum.py)

## 2 Add Two Numbers

### Description
You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
You may assume the two numbers do not contain any leading zero, except the number 0 itself.
**Input**: (2 -> 4 -> 3) + (5 -> 6 -> 4)
**Output**: 7 -> 0 -> 8

**é¢˜ç›®ç†è§£**ï¼šç´¯åŠ çš„å‡½æ•°ï¼Œé“¾è¡¨çš„å¤´æ˜¯ä¸ªä½ï¼Œä»¥æ­¤ç±»æ¨ã€‚ä¾‹å­æŒ‰ç…§åè¿›åˆ¶åŠ å‡å°±æ˜¯ï¼š342 + 465 =807ã€‚åœ¨å®ç°è¿‡ç¨‹ä¸­ï¼Œæ³¨æ„è¿›ä½ã€‚
Result:[Add Two Numbers](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/2_addTwoNumbers.py)

## 7 Reverse Integer

### Description
Reverse digits of an integer.
**Example1**: x = 123, return 321
**Example2**: x = -123, return -321

**Note**:
The input is assumed to be a 32-bit signed integer. Your function should **return 0 when the reversed integer overflows**.

**é¢˜ç›®ç†è§£**ï¼šè¿™é‡Œè¦æ³¨æ„æœ‰ä¸ª integer overflowsã€‚

Result:[Reverse Integer](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/7_reverse_integer.py)

## 9 Palindrome Number

### Description
Determine whether an integer is a palindrome. Do this without extra space.

**ç†è§£é¢˜ç›®**ï¼šåˆ¤æ–­ä¸€ä¸ªæ•´å½¢æ•°å­—æ˜¯å¦æ˜¯å›æ–‡ã€‚

[click to show spoilers.](https://leetcode.com/problems/palindrome-number/#/description)

Result:[Palindrome Number](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/9_palindromeNumber.py)

## 13 Roman to Integer

### Description
Given a roman numeral, convert it to an integer.
Input is guaranteed to be within the range from 1 to 3999.

**é¢˜ç›®ç†è§£**: å°†ç½—é©¬æ•°å­—è½¬æ¢æˆæ•´å‹æ•°å­—ã€‚é¦–å…ˆè¦ç†è§£ç½—é©¬æ•°å­—çš„è®¡ç®—æ–¹å¼ã€‚å¤§æ•°å·¦è¾¹çš„ä¸ºå‡å³è¾¹æ˜¯åŠ ã€‚

Result:[Roman to Integer](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/13_romanToint.py)

## 14 Longest Common Prefix

### Description
Write a function to find the longest common prefix string amongst an array of strings.

Result:[Longest Common Prefix](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/14_LongestCommonPrefix.py)

## 20 Valid Parentheses

### Description
Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.
The brackets must close in the correct order, "()" and "()[]{}" are all valid but "(]" and "([)]" are not.

**é¢˜ç›®ç†è§£**ï¼šè¿™é“é¢˜ç”¨æ ˆçš„æ–¹å¼å®ç°ï¼Œéå†å­—ç¬¦ä¸²ï¼Œæ£€éªŒåˆ°å·¦æ‹¬å·å…¥æ ˆï¼Œæ£€éªŒåˆ°å³æ‹¬å·æ—¶ï¼Œå‡ºæ ˆæ£€éªŒæ˜¯å¦åŒ¹é…ï¼Œæœ€åæ£€éªŒæ ˆæ˜¯å¦ä¸ºç©ºï¼Œæ’é™¤å³æ‹¬å·ç¼ºå¤±çš„æƒ…å†µã€‚

Result:[Valid Parentheses](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/20_ValidParentheses.py)

## 21 Merge Two Sorted Lists

### Description
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.

**é¢˜ç›®ç†è§£** åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨ï¼Œåˆæˆçš„åˆ—è¡¨ä¹Ÿæ˜¯æœ‰åºçš„ã€‚æ–¹æ³•æ˜¯ï¼Œåˆ›å»ºä¸€ä¸ªæ–°çš„èŠ‚ç‚¹ï¼Œç©¿æ’è¿æ¥ä¸¤ä¸ªè¾“å…¥é“¾è¡¨ã€‚

Resultï¼š[Merge Two Sorted Lists](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/21_MergeTwoSortedLists.py)

## 26 Remove Duplicates from Sorted Array

### Description
Given a sorted array, remove the duplicates in place such that each element appear only once and return the new length.
**Do not allocate extra space for another array, you must do this in place with constant memory.**

For example,
Given input array *nums = [1,1,2]*,

Your function should return length = 2, with the first two elements of nums being 1 and 2 respectively. It doesn't matter what you leave beyond the new length.

Result:[Remove Duplicates from Sorted Array](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/26_RmDuplicatesFSortedArray.py)

## 27 Remove Element

### Description
Given an array and a value, remove all instances of that value in place and return the new length.

Do not allocate extra space for another array, you must do this in place with constant memory.

The order of elements can be changed. It doesn't matter what you leave beyond the new length.

**Example:**
Given input array nums = [3,2,2,3], val = 3

Your function should return length = 2, with the first two elements of nums being 2.

**é¢˜ç›®ç†è§£**ï¼šå’Œ[26 Remove Duplicates from Sorted Array](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/Catalogue.mdown#26-remove-duplicates-from-sorted-array) ç±»ä¼¼ï¼Œåœ¨åŸåˆ—è¡¨ä¸­è®¾ç½®ä¸¤ä¸ªæŒ‡é’ˆï¼Œä¸€ä¸ªè¿›è¡Œéå†ï¼Œå¦ä¸€ä¸ªè¿›è¡Œèµ‹å€¼å¹¶è®¡ç®—æ–°çš„length

Result:[Remove Element](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/27_RemoveElement.py)

## 28 Implement strStr()

### Description
Implement strStr().

Returns the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.

**é¢˜ç›®ç†è§£**: ç®€å•çš„ç®—æ³•ï¼Œå¤æ‚åº¦O(n^2),å¯ä»¥ä½¿ç”¨kmpç®—æ³•å°†å¤æ‚åº¦é™è‡³O(n)

Result:[Implement strStr()](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/28_strStr.py)

## 35 Search Insert Position

### Description
Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

Here are few examples.
>[1,3,5,6], 5 â†’ 2

>[1,3,5,6], 2 â†’ 1

>[1,3,5,6], 7 â†’ 4

>[1,3,5,6], 0 â†’ 0

[View in Leetcode](https://leetcode.com/problems/search-insert-position/#/description)

Result: [Search Insert Position](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/35_SearchInsert.py)

## 38 Count and Say

### Description
The count-and-say sequence is the sequence of integers beginning as follows:
1, 11, 21, 1211, 111221, ...

>1 is read off as "one 1" or 11.

>11 is read off as "two 1s" or 21.

>21 is read off as "one 2, then one 1" or 1211.

Given an integer n, generate the nth sequence.

Note: The sequence of integers will be represented as a string.

**é¢˜ç›®ç†è§£**: éœ€è¦ç”¨åˆ°è¿­ä»£ã€‚

[View in Leetcode](https://leetcode.com/problems/count-and-say/#/description)

Result: [Count and Say](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/0-99/38_CountAndSay.py)

## 53 Maximum Subarray

### Description
Find the contiguous subarray within an array (containing at least one number) which has the largest sum.

For example, given the array [-2,1,-3,4,-1,2,1,-5,4],
the contiguous subarray [4,-1,2,1] has the largest sum = 6.

[Maximum Subarray](https://github.com/NaughtyFlame/LeetCode/tree/master/Algorithms/0-99/53_maxSubArray.py)

## 58 Length of Last Word

### Description
Given a string s consists of upper/lower-case alphabets and empty space characters ' ', return the length of last word in the string.

If the last word does not exist, return 0.

**Note:** A word is defined as a character sequence consists of non-space characters only.

For example,
Given s = **"Hello World"**,
return **5**.

Result: [Length of Last Word](https://github.com/NaughtyFlame/LeetCode/tree/master/Algorithms/0-99/58_LenLastWord.py)

## 66 Plus One

### Description
Given a non-negative integer represented as a **non-empty** array of digits, plus one to the integer.

You may assume the integer do not contain any leading zero, except the number 0 itself.

The digits are stored such that the most significant digit is at the head of the list.

Result: [Plus One](https://github.com/NaughtyFlame/LeetCode/tree/master/Algorithms/0-99/66_PlusOne.py)

## 67 Add Binary

### Description
Given two binary strings, return their sum (also a binary string).

For example,
a = "11"
b = "1"
Return "100".

[view in Leetcode](https://leetcode.com/problems/add-binary/#/description)

Result: [Add Binary](https://github.com/NaughtyFlame/LeetCode/tree/master/Algorithms/0-99/67_addBinary.py)

## 69 Sqrt(x)

### Description
Implement int sqrt(int x).
Compute and return the square root of x.

[view in Leetcode](https://leetcode.com/problems/sqrtx/#/description)

åˆ†æï¼šæ­¤é¢˜éœ€è¦è¿”å›çš„å€¼æ˜¯intå½¢å¼çš„ï¼Œæ‰€ä»¥ç”¨äºŒåˆ†æ³•æœ€ä¸ºåˆé€‚ï¼Œå¦‚æœè®¡ç®—floatæ ¼å¼å¹³æ–¹æ ¹ï¼Œå¯ä»¥ä½¿ç”¨ç‰›é¡¿è¿­ä»£æ³•ã€‚

Result: [Sqrt(x)](https://github.com/NaughtyFlame/LeetCode/tree/master/Algorithms/0-99/69_mysqrt_1.py)

## 70 Climbing Stairs

### Description
You are climbing a stair case. It takes n steps to reach to the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

**Note** : Given n will be a positive integer.

[view in Leetcode](https://leetcode.com/problems/climbing-stairs/#/description)

Result: [Climbing Stairs](https://github.com/NaughtyFlame/LeetCode/tree/master/Algorithms/0-99/70_climbStairs.py)

## 83 Remove Duplicates from Sorted List

### Description
Given a sorted linked list, delete all duplicates such that each element appear only once.

For example,

Given **1->1->2**, return **1->2**.

Given **1->1->2->3->**3, return **1->2->3**.

[view in leetcode](https://leetcode.com/problems/remove-duplicates-from-sorted-list/description/)

[Solution](https://github.com/NaughtyFlame/LeetCode/tree/master/Algorithms/0-99/083_Remove_Duplicates_1.py)

## 88 Merge Sorted Array
Given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.

**Note**:

You may assume that nums1 has enough space (size that is greater or equal to m + n) to hold additional elements from nums2. The number of elements initialized in nums1 and nums2 are m and n respectively.

[view in leetcode](https://leetcode.com/problems/merge-sorted-array/description/)

[Solution](https://github.com/NaughtyFlame/LeetCode/tree/master/Algorithms/0-99/088_Merge_Sorted_Array.py)

## 121 Best Time to Buy and Sell Stock

### Description
Say you have an array for which the ith element is the price of a given stock on day i.
If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.

**Example 1**
```
Input: [7, 1, 5, 3, 6, 4]
Output: 5

max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)
```
**Example 2**
```
Input: [7, 6, 4, 3, 1]
Output: 0

In this case, no transaction is done, i.e. max profit = 0.
```

**ç†è§£**
éœ€è¦ä¿å­˜çš„å€¼ä¸ºæœ€å°å€¼minå’Œæœ€å¤§å·®å€¼ï¼Œå¦‚æœå½“å‰å€¼å°äºminï¼Œåˆ™è¿›è¡Œæ›¿æ¢ï¼Œå¦‚æœå¤§äºå½“å‰å€¼ï¼Œåˆ™è¿›è¡Œç›¸å‡å¹¶æ¯”è¾ƒæœ€å¤§å·®å€¼ã€‚

[Solution](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/100-199/121_Best_time_Stock.py)

## 122 Best Time to Buy and Sell Stock II

### Description
Say you have an array for which the ith element is the price of a given stock on day i.

Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).

**ç†è§£**

ä¸ä¸Šä¸€é¢˜ä¸åŒçš„æ˜¯ï¼Œè¿™é‡Œå¯ä»¥è¿›è¡Œå¤šæ¬¡ä¹°å–ï¼Œæ¥è¿›è¡Œæœ€å¤§çš„æ”¶ç›Šã€‚ä¸çœŸå®çš„è‚¡ç¥¨ä¹°å–ä¸åŒï¼Œè¿™é‡Œæ²¡æœ‰æœ¬é‡‘çš„æ¦‚å¿µï¼Œæ¯æ¬¡å‡ºå…¥ä¸€ä»½ï¼Œè€Œä¸”å…¥çš„æ—¶å€™é¡»ä¿è¯æ‰‹ä¸Šæ²¡æœ‰å…ƒç´ ã€‚

**æ€è€ƒ**

é€šç”¨ç®—æ³•ä¸ºï¼š
é€‰å–ä¸€ä¸ªmin å¦‚æœç¢°åˆ°æ›´å°åˆ™è¿›è¡Œæ›¿æ¢ï¼Œç¢°åˆ°å½“å‰å€¼ä¸‹ä¸€ä½æ˜¯å‡å°çš„æƒ…å†µä¸‹è¿›è¡Œå·®å€¼è®¡ç®—ï¼Œå¹¶ç´¯ç§¯è¿™ä¸ªå·®å€¼ã€‚
ç»è¿‡æ€è€ƒï¼Œæ›´æ–°ç®—æ³•ï¼š
ä¿å­˜ä¸€ä¸ªlowå€¼ï¼Œä¸€ä¸ªä¸ºhighå€¼ã€‚
å¦‚æœå½“å‰å…ƒç´ æ¯”lowå°ï¼Œåˆ™æ›¿æ¢lowï¼Œå¦‚æœå½“å‰å…ƒç´ æ¯”highå¤§åˆ™æ›¿æ¢highï¼Œå¦‚æœæ¯”highå°ï¼Œè¯´æ˜ä¸Šä¸€ä¸ªå€¼å·²ç»æ˜¯ä¸Šä¸ªé˜¶æ®µçš„æœ€å¤§å€¼ï¼Œæ­¤æ—¶è¿›è¡Œprofitè®¡ç®—ï¼Œå¹¶æŠŠlowä¸highå€¼èµ‹å€¼ä¸ºå½“å‰å€¼ã€‚

### å®ä¾‹
**[2,1,3,5,2,7]**

**[3,2,1]**

[Solution](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/100-199/122_Best_time_Stock_2.py)

## 125 Valid Palindrome

### Description
Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.

For example,
**"A man, a plan, a canal: Panama"** is a palindrome.
**"race a car"** is not a palindrome.

**Note:**
Have you consider that the string might be empty? This is a good question to ask during an interview.

For the purpose of this problem, we define empty string as valid palindrome.

**æ€è€ƒ**

æ™®é€šçš„å›æ–‡é—®é¢˜ï¼Œéœ€è¦åšçš„æ˜¯å¿½ç•¥ç‰¹æ®Šå­—ç¬¦ï¼Œç„¶åä¸€å¤´ä¸€å°¾å›æ–‡åŒ¹é…ã€‚

[Solution](https://github.com/NaughtyFlame/LeetCode/blob/master/Algorithms/100-199/125_Valid_Palindrome.py)

## Single Number

### Description
Given an array of integers, every element appears twice except for one. Find that single one.

**Note:**
Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory?

**æ€è€ƒ**

è¿™é‡Œæœ‰ä¸€ä¸ªè®¨å·§çš„æ–¹å¼ï¼Œxå¼‚æˆ–xä¸º0ï¼Œè€Œä»»ä½•æ•°å¼‚æˆ–0å¾—åˆ°æœ¬èº«ã€‚

## 141 Linked List Cycle

### Description
Given a linked list, determine if it has a cycle in it.

Follow up:
Can you solve it without using extra space?

**æ€è€ƒ**

å¸¸è§„ç®—æ³•ï¼š
è®¾å®šä¸¤ä¸ªæŒ‡é’ˆaä¸bï¼Œaæ¯èµ°ä¸€æ­¥bä»å¤´å¼€å§‹èµ°ï¼Œè‹¥b = a.next åˆ™è¯´æ˜æ­¤é“¾è¡¨æœ‰ç¯ã€‚è‹¥a = bè¯´æ˜è¿˜æ²¡æœ‰åˆ¤æ–­å‡ºæ˜¯å¦æœ‰ç¯ï¼Œaå†èµ°ä¸€æ­¥ï¼Œbä»å¤´å¼€å§‹ã€‚å½“a.next = None åˆ™è¯´æ˜æ­¤é“¾è¡¨æ²¡æœ‰ç¯ã€‚æ—¶é—´å¤æ‚åº¦ä¸º O(n^2)

æ”¹å–„ç‰ˆï¼š
åŒæ ·è®¾å®šä¸¤ä¸ªæŒ‡é’ˆaä¸bï¼Œaçš„é€Ÿåº¦ä¸ºbçš„ä¸¤å€ã€‚å¦‚æœè¿™ä¸ªé“¾è¡¨æœ‰ç¯...ä»–ä»¬æ€»æœ‰ä¸€å¤©ä¼šç›¸é‡çš„ğŸ˜³ã€‚æ—¶é—´å¤æ‚åº¦ä¸ºO(n)ã€‚

## 155 Min Stack

### Description
Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.

* push(x) -- Push element x onto stack.
* pop() -- Removes the element on top of the stack.
* top() -- Get the top element.
* getMin() -- Retrieve the minimum element in the stack.

**Example**

```
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> Returns -3.
minStack.pop();
minStack.top();      --> Returns 0.
minStack.getMin();   --> Returns -2.
```
**æ€è€ƒ**

è¿™é‡Œéœ€è¦ç”¨stackæ¥è¿”å›æ ˆä¸­çš„æœ€å°å€¼ï¼Œå› ä¸ºå¦‚æœæ˜¯ç”¨intï¼Œä¸€æ—¦å½“å‰æœ€å°æ—¶popå‡ºå»ï¼Œæ— æ³•æ‰¾åˆ°ç¬¬äºŒå°çš„å…ƒç´ äº†ã€‚è¿˜æœ‰ä¸€ä¸ªè¦æ³¨æ„çš„åœ°æ–¹çš„æ˜¯ï¼Œpushä¸€ä¸ªç­‰äºminstack é¡¶éƒ¨çš„æ•°æ—¶ï¼Œä¹Ÿè¦æŠŠä»–pushè¿›min stackã€‚

## 160 Intersection of Two Linked Lists

### Description

Write a program to find the node at which the intersection of two singly linked lists begins.
For example, the following two linked lists:
```
A:          a1 â†’ a2
                   â†˜
                     c1 â†’ c2 â†’ c3
                   â†—            
B:     b1 â†’ b2 â†’ b3
```
begin to intersect at node c1.
**Notes:**
* If the two linked lists have no intersection at all, return null.
* The linked lists must retain their original structure after the function returns.
* You may assume there are no cycles anywhere in the entire linked structure.
* Your code should preferably run in O(n) time and use only O(1) memory.
**Credits:**
Special thanks to [@stellari](https://oj.leetcode.com/discuss/user/stellari) for adding this problem and creating all test cases.

**æ€è€ƒ**

åŸºç¡€æ€è·¯ï¼š
éå†ä¸¤æ¡é“¾è¡¨è®°å½•é•¿åº¦ï¼Œè®¡ç®—å·®å€¼ï¼Œç„¶åè®©é•¿çš„é‚£æ¡çº¿èµ°å‡ æ­¥ï¼ŒæŒ‡é’ˆç›¸åŒçš„æ—¶å€™å°±æ˜¯èŠ‚ç‚¹ã€‚å¦‚æœæœ«å°¾ä¸åŒå°±æ˜¯æ²¡æœ‰èŠ‚ç‚¹ã€‚

è¿›é˜¶æ€è·¯ï¼š
å½“æŒ‡é’ˆèµ°åˆ°æœ«å°¾çš„æ—¶å€™ï¼Œä»å¦ä¸€æ¡é“¾è¡¨çš„å¼€å¤´å¼€å§‹ç»§ç»­ç§»åŠ¨ï¼Œè¿™æ ·ä¼šå¯¼è‡´ä¸¤ç§æƒ…å†µï¼š
1. åœ¨èŠ‚ç‚¹å¤„ç›¸é‡
2. åŒæ—¶åˆ°è¾¾å¯¹æ–¹çš„æœ«å°¾
å› ä¸ºå®ƒä»¬èµ°è¿‡çš„è·¯ç¨‹æ˜¯ä¸€æ ·çš„ã€‚

## 167 Two Sum II - Input array is sorted

### Description

Given an array of integers that is already **sorted in ascending order**, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.

You may assume that each input would have exactly one solution and you may not use the same element twice.

**Input**: numbers={2, 7, 11, 15}, target=9
**Output**: index1=1, index2=2

**æ€è€ƒ**

è¿™ä¸ªé¢˜ç›®å¯ä»¥ç”¨æš´åŠ›ç®—æ³•æ¥æ±‚è§£çš„ï¼Œä½†æ˜¯åˆæ›´å¿§è§£ï¼Œæˆ‘çš„æƒ³æ³•æ˜¯ç”¨å“ˆå¸Œè¡¨ã€‚keyä¸ºéœ€è¦åŒ¹é…çš„æ•°ï¼ˆä¹Ÿå°±æ˜¯ tagartå‡å»æœ¬èº«ï¼‰ï¼Œvalueä¿å­˜è¿™ä¸ªå€¼çš„indexï¼ˆæ³¨æ„é¢˜ç›® è¾“å‡ºçš„indexæ¯”å®é™…å¤§1ï¼‰ã€‚è¿›è¡Œéå†ï¼Œå¦‚æœå½“å‰å€¼ä¸åœ¨å“ˆå¸Œè¡¨ä¸­ï¼Œåˆ™å»ºç«‹æ–°çš„ä¸€è¡Œã€‚å¦‚æœåœ¨å“ˆå¸Œè¡¨ä¸­æ‰¾åˆ°è¿™ä¸ªkeyï¼Œåˆ™è¾“å‡ºvalueå’Œè¿™ä¸ªæ•°åœ¨åˆ—è¡¨ä¸­çš„indexã€‚

## 168 Excel Sheet Column Title

### Description

Given a positive integer, return its corresponding column title as appear in an Excel sheet.

For example:
```
1 -> A
    2 -> B
    3 -> C
    ...
    26 -> Z
    27 -> AA
    28 -> AB
```
**æ€è€ƒ**

åè¿›åˆ¶å’Œ26è¿›åˆ¶çš„è½¬æ¢ã€‚æ³¨æ„è½¬æ¢ä¹‹åæ˜¯ä»Aå¼€å§‹çš„ï¼Œä¸æ˜¯é›¶ã€‚åœ¨æ±‚ä½™æ•°çš„æ—¶å€™æ³¨æ„è¦å‡å»1ã€‚ç„¶åç”¨ASCIIç è¿›è¡Œè½¬æ¢ã€‚

## 169 Majority Element

### Description
Given an array of size n, find the majority element. The majority element is the element that appears **more than** âŒŠ n/2 âŒ‹ times.

You may assume that the array is non-empty and the majority element always exist in the array.

**Credits**:
Special thanks to [@ts](https://oj.leetcode.com/discuss/user/ts) for adding this problem and creating all test cases.

ç”¨å“ˆå¸Œè¡¨ä¿å­˜æ•°å­—çš„è®¡æ•°ã€‚

## 171 Excel Sheet Column Number

### Description

Given a column title as appear in an Excel sheet, return its corresponding column number.

For example:
```
    A -> 1
    B -> 2
    C -> 3
    ...
    Z -> 26
    AA -> 27
    AB -> 28
```

## 172 Factorial Trailing Zeroes

### Description

Given an integer n, return the number of trailing zeroes in n!.

**Note**: Your solution should be in logarithmic time complexity.

æ•°5çš„ä¸ªæ•°ã€‚

## 189 Rotate Array

### Description

Rotate an array of n elements to the right by k steps.

For example, with n = 7 and k = 3, the array **[1,2,3,4,5,6,7]** is rotated to **[5,6,7,1,2,3,4]**.

**Note**:
Try to come up as many solutions as you can, there are at least 3 different ways to solve this problem.

## 190 Reverse Bits

### Description

Reverse bits of a given 32 bits unsigned integer.

For example, given input 43261596 (represented in binary as 00000010100101000001111010011100), return 964176192 (represented in binary as 00111001011110000010100101000000).

## 191 Number of 1 Bits

### Description

Write a function that takes an unsigned integer and returns the number of â€™1' bits it has (also known as the Hamming weight).

For example, the 32-bit integer â€™11' has binary representation 00000000000000000000000000001011, so the function should return 3.

Hamming Weight æœ‰å¥½å¤šä¸­ç®—æ³•ã€‚å…·ä½“å¹¶æ²¡æœ‰ç ”ç©¶ã€‚ æ™®é€šçš„ä½æ“ä½œå¹¶ä¸èƒ½é€šè¿‡æ•ˆç‡æ£€æµ‹ã€‚
